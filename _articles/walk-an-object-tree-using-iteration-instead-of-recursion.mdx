---
title: 'Walk an Object tree using iteration instead of recursion'
createdAt: 2023-02-08T23:00:00.000Z
thumbnail: /thumbnails/abstract.jpeg
subtitle: Recursive who?
shortDescription: >
  Explore an alternative approach in walking through an object tree using iteration instead of recursion.
---

import { Highlight } from '@/components/highlight';

One day at work I had to walk through a complex data structure to remove some circular references (Contentful anyone?) and stumbled upon this error:

```bash
RangeError: Maximum call stack size exceeded (Chrome)
InternalError: too much recursion (Firefox)
RangeError: Maximum call stack size exceeded. (Safari)

# Some browsers are a bit more human than others at telling you the bad news ðŸ‘€
```

I was using a fancy recursive function to traverse this data and I got hit by the max call stack size defined for the node process.
Bummer. The worst thing is that this compromised production and because we didn't add error handling to this function our users were experiencing a Black Screen of Death.

<br />

By the end of this article <Highlight color="red">you will learn how to avoid this situation by converting a recursive function into it's iterative counterpart</Highlight>.
But first I will give you a small introduction to the recursive approach.

<br />

## The dawnfall of the recursive function

<br />
For reference, this is a simplified version of the code that caused all this mess:

<br />

```js title="normalize.js"
function normalizeObject(object) {
  if (Array.isArray(object)) {
    for (item of object) {
      normalizeData(item);
    }
  } else if (isObject(object)) {
    for (property in object) {
      // We were doing things here to check candidates for circular references and remove them.

      normalizeData(object[property]);
    }
  }
}

normalizeObject(complexObject);
```

The recursion to walk an object tree is simple, some properties might be Array and some others might be Object, for other types we don't do anything because they are primitives.

<br />
If the current recursive call value is an Array we loop through it and call the recursion
on each element. On the other hand, if the current value is an Object we loop through
every property and call the recursive function on it's value.
<br />

If the initial Object is very deep and has a lot of properties then you can get hit by the Stack Size limit error.

<br />

# Buckle up, things are going to get interesting

<br />

After some research I found an option to increase the stack size **--stack-size**
but that didn't feel right. I have nothing against that option, if it solves the
problem it should be fine, right? But it led me to think that maybe my recursive
function was also consuming a lot of memory and I didn't want to allow it consume
more by increasing the stack size.

<br />

So, back to our problem solving, after some more research I came across [this article](https://exploringjs.com/es6/ch_tail-calls.html) about **tail call optimization**.

> ECMAScript 6 offers tail call optimization, where you can make some function calls without growing the call stack.

Well, that looks promising BUT seconds later I got hit by reality. ðŸ¤¯

> Warning: Even though tail call optimization is part of the language specification, it isnâ€™t supported by many engines and that may never change.

Back to square one, I had to find an alternative and that's when I found out about the iterative approach.

<br />

# Our oldest friend, the iteration

<br />

The concept for the iterative approach is simple, it uses a stack or queue to sequentially process elements of a data structure without recursion.

<br />

```js title="normalize.js"
function normalizeObject(object) {
  let queue = [object];

  while (queue.length) {
    const current = queue.shift();

    if (Array.isArray(current)) {
      queue = [...queue, ...current];
    }

    if (isObject(current)) {

      // we can do something with the object
      for (const property in current) {
        queue.push(current[property]);
      }
    }
  }
}

...

normalizeObject(complexObject);
```

Problem solved! We managed to walk through complex objects without any error.

<br />

Be careful though and always analyze your use case because, from my experience, iterative
approach can sometimes be slower than recursion. But that doesn't matter if the recursion throws
an error right? ðŸ˜„
